# 유전 알고리즘

유전자 알고리즘은 답에 맞는 해를 찾기위해 다음 자손을 만들어가며 최적값을 찾는 알고리즘이다.

유전자 알고리즘은 크게 3파트로 나뉜다.

### 1. 선택 연산

### 2.  교차 연산

### 3. 돌연변이 연산



[최저임금위원회](http://minimumwage.go.kr/stat/statMiniStat.jsp)

우리나라의 연도별 최저임금을 정리한 사이트이다. 이 데이터 값들을 가지고 어떤 회귀식을 나타내는지 알아보자.



최저임금을 그대로 쓰면 기울기 값때문에 비트가 많아지고 최적도계산 때 너무 복잡해져서 단위를 100원으로 하였다.

또한 년도도 그대로 쓰면 계산이 불편하여 1989년을 0으로 두고 알고리즘을 진행하였다.



![임금그래프](https://user-images.githubusercontent.com/62462277/85820501-51f00400-b7b1-11ea-93ed-a536694d0714.png)



위는 최저임금을 나타낸 그래프이다. 

이 데이터에 대한 회귀식을 구하기 위해 식의 형태를 f(x) = ax+6으로 두고 진행하자.







처음의 후보 해는 4,15,7,30,17,24,26,11로 두고 풀이해보겠다.



후에 최적도를 구하기위해 mse를 먼저 간략화 해보자.



(y = x<sub>i </sub>년의 최저임금) 

![](https://user-images.githubusercontent.com/62462277/85821929-a5178600-b7b4-11ea-98fc-3d54d294d208.png)




이 때 시그마를 풀었을 때 나오는 y은 엑셀을 이용해서 쉽게 풀 수 있다.

![](https://user-images.githubusercontent.com/62462277/85809359-9d46ea00-b792-11ea-99ee-577a110bd4d8.png)

위 표를 보고 식을 다시 정리하면 

mse = 10416a^2-45548.89+59816.9가 나온다.

이 때 mse가 크면 클수록 a가 해에 부적합하다는 뜻이므로 mse를 토대로 역계산해주어 최적해를 구한다. 또한 그 최적도를 퍼센티지로 할당해주어 선택연산을 준비한다.

| 후보해 | a 값 | 최적도     | 전체 % |
| ------ | ---- | ---------- | ------ |
| f1     | 4    | 8067749.3  | 20%    |
| f2     | 15   | 6391843.09 | 16%    |
| f3     | 7    | 7860667.97 | 19%    |
| f4     | 30   | 44276.44   | 0.1%   |
| f5     | 17   | 5816316.87 | 14%    |
| f6     | 24   | 3145767.1  | 8%     |
| f7     | 26   | 2195264.88 | 5%     |
| f8     | 11   | 7292911.53 | 17.9%  |



### 1. 선택연산

최적도기준으로 퍼센티지를 나타내어 룰렛을 돌려 다시 후보해 8개를 선택해준다. f1,f3은 2번, f2,f5,f6,f7은 1번씩 선택됐다고 하자

이 때 뽑힌 것을 (f2,f3) , (f3,f1) , (f6,f1) , (f7,f3) 이라 해보자. 괄호는 번식하게 될 서로의 상대이다.

그리고 해당 해들을 2진 비트로 나타내어주자.

| 뽑힌 후보해 | a값  | 비트  |
| ----------- | ---- | ----- |
| f2          | 15   | 01111 |
| f5          | 17   | 10001 |
| f3          | 7    | 00111 |
| f1          | 4    | 00100 |
| f6          | 24   | 11000 |
| f1          | 4    | 00100 |
| f7          | 26   | 11010 |
| f3          | 7    | 00111 |



### 2. 교차연산

교차 연산은 서로 짝이 된 한 쌍의 염색체에서 하나는 왼쪽의 두 비트, 나머지 염색체의 오른쪽 세 비트를 합치는 교차연산을 선택했다.

아래 사진이 그 과정이다.



![](https://user-images.githubusercontent.com/62462277/85815935-d720ec00-b7a4-11ea-990f-e67f788cdb92.jpg)



### 3. 돌연변이 연산

돌연변이의 확률은 일반적으로 (1/모집단 크기)~(1/후보해들의 bit수) 범위 안에서 정한다. 그렇기 때문에 여기서는 8개의 후보해를 생각하여 돌연변이 확률을 1/8로 잡아줬고, 비율에 맞게 여기선 돌연변이가 1번 발생했다고 하자.

위 사진에서 2번째 교차중 00100의 오른쪽에서 2번째 비트가 반전된다고 가정하겠다.

아래는 돌연변이 연산이 된 후의 표이다.

| 변이 전 비트 | 변이 후 비트 | 최종해 (a 값) |
| ------------ | ------------ | ------------- |
| 01001        | 01001        | 9             |
| 10111        | 10111        | 23            |
| 00100        | 01100        | 12            |
| 00111        | 00111        | 7             |
| 11100        | 11100        | 28            |
| 00000        | 00000        | 0             |
| 11111        | 11111        | 31            |
| 00111        | 00111        | 7             |



이제 위 최종해들이 다시 후보해로 들어가 최적도를 계산하게된다.

| 후보해 | 최적도     | 전체 % |
| ------ | ---------- | ------ |
| 9      | 8223821.32 | 17     |
| 23     | 4195137.78 | 9      |
| 12     | 7704259.99 | 16     |
| 7      | 8466035.54 | 17.9   |
| 28     | 1766802.23 | 4      |
| 0      | 8657577.31 | 18     |
| 31     | 59816.9    | 0.1%   |
| 7      | 8466035,54 | 18     |



### 정리

1세대에서 얻은 최적해에 가까운 값은 4였다.  그런데 2세대에서는 4의 최적도보다 큰, 즉 최적해에 더 가까운 값인 0이 나왔다.

이렇게 3단계를 반복해나가며 세대간의 값의 차이가 미미해질때 쯤,  최적해를 구할 수 있을 것이다.



### 느낀점

처음에 이 알고리즘을 공부할 때, 굳이 돌연변이라는 요소를 왜 넣는지 몰랐다.

하지만 직접해보면서, 위에서도 나오듯이 11 101와   01 101을 교차하면 다시 똑같은 수가 나온다. 즉 해의 다양성이 떨어진다.

그리고 다른 이유로는 최적해가 원래의 해와 반대의 방향으로 갈 수도 있는 상황을 벗어나기 위함도 있다고 한다. 

처음에는 이런 돌연변이 연산이 최적해를 찾는 것을 방해할 것이라고 생각했는데 직접해보니 필요한 연산이라는 것을 느꼈다.